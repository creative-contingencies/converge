<?php

/**
 *
 * Handle session selection info
 *
 * We are coupling a bit with registration. After all, we need to know which ticket
 * a user has purchased, so we can allow them to pick appropriate sessions.
 */

/**
 * Implementation of hook_perm().
 *
 */
function sessions_perm() {
  return array('choose conference sessions');
}

/**
 * Implementation of hook_nodeapi()
 *
 * TODO: Select the node type to use as a timeslot.
 */
function sessions_nodeapi(&$node, $op) {
  switch ($op) {
    case 'load':
      if ($node->type == 'timeslot') {
        // Create a formatted session time string.
        $dateparts = split(' ', $node->title);
        $node->between = t('!start - !end', array('!start' => $dateparts[4], '!end' => $dateparts[6]));

        // Grab the nid of the day we're attached to.
        $node->day = db_result(db_query("SELECT nid FROM {content_field_day_timeslots} WHERE field_day_timeslots_nid=%d", $node->nid));
      }

      if ($node->type == 'proposal') {
        $node->attendees = intval(sessions_attendees($node->nid));
        $capacity = intval(db_result(db_query("SELECT ctr.field_room_capacity_value FROM {content_type_proposal} AS ctp LEFT JOIN {content_type_room} AS ctr ON (ctp.field_proposal_room_nid = ctr.nid) WHERE ctp.nid = %d", $node->nid)));
        $node->capacity = $capacity;
        $node->full = ($node->capacity < $node->attendees);
      }
      break;
  }
}

/**
 * Implementation of hook_menu().
 */
function sessions_menu() {
  $items = array();

 // Admin page.
  $items['admin/settings/sessions'] = array(
    'title' => 'CCC Session Selection Settings',
    'description' => 'Change configuration for Session Selection',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('sessions_admin_settings'),
    'access arguments' => array('administer site configuration'),
    'type' => MENU_LOCAL_TASK,
  );

  $items['user/%user/sessions'] = array(
    'title' => 'Session Selections',
    'description' => 'Conference session selection',
    'page callback' => 'sessions_list',
    'page arguments' => array(1, 3, 4, 5),
    'access callback' => 'user_access',
    'access arguments' => array('choose conference sessions'),
    'type' => MENU_LOCAL_TASK,
  );

  return $items;
}

/**
 * Administration settings.
 */
function sessions_admin_settings() {

  $form['sessions'] = array(
    '#type' => 'fieldset',
    '#title' => 'Session Selection',
    '#description' => t('General session selection settings.'),
  );

  $form['sessions']['sessions_proposal_status'] = array(
    '#type' => 'checkboxes',
    '#title' => 'Propsal Status',
    '#description' => t('Acceptance status a proposal needs before it is scheduled, and can thus be selected.'),
    '#options' => content_allowed_values(content_fields('field_proposal_status')),
    '#default_value' => variable_get('sessions_proposal_status', array('accepted')),
  );

  $statuses = uc_order_state_list();
  foreach ($statuses as $status) {
    $options[$status['id']] = $status['title'];
  }
  $form['sessions']['sessions_order_status'] = array(
    '#type' => 'checkboxes',
    '#title' => 'Payment Status',
    '#description' => t('Payment status needed before sessions can be selected.'),
    '#options' => $options,
    '#default_value' => variable_get('sessions_order_status', array('completed')),
  );

  return system_settings_form($form);
}

/**
 * Implementation of hook_user().
 */
function sessions_user($op, &$edit, &$account, $category = NULL) {
  global $user;
  switch ($op) {
    case 'view':
      if ($user->uid && (($user->uid == $account->uid && user_access('choose conference sessions')))) {

        // If presenter or co-presenter, select OWN sessions and assign them.
        //
        sessions_presenter_select($account->uid);

        // Get a big list of selected sessions.
        $sessions = sessions_user_sessions($account->uid);

        // Show selected sessions.
        $account->content['selections'] = array(
          '#type' => 'user_profile_category',
          '#weight' => 0,
          '#title' => t('Session Selections'),
          'link' => array(
            '#type' => 'user_profile_item',
            '#value' => theme('user_overview_registrations', $account, $sessions),
          ),
        );
      }

      break;

    case 'load':
      $account->selections = sessions_user_sessions($account->uid);
      break;
  }
}

/**
 * Helper that retrieves ACCEPTED sessions that a user is presenting.
 *
 * @param uid
 *   A user uid.
 */
function sessions_presenter($uid) {
  $nids = array();

  $query = "SELECT
    n.nid AS nid
  FROM
    {node} AS n
  INNER JOIN
    {content_type_proposal} AS ctp ON n.vid = ctp.vid
  LEFT JOIN
    {content_field_proposal_presenters} AS cfpp ON (n.vid = cfpp.vid)
  WHERE
    n.type = 'proposal'
    AND n.status <> 0
    AND ctp.field_proposal_status_value IN ('" . implode("','", variable_get('sessions_proposal_status', array('accepted'))) ."')
    AND cfpp.field_proposal_presenters_uid = %d
  ORDER BY nid ASC";
  $result = db_query($query, $uid);

  while ($nid = db_result($result)) {
    $nids[] = $nid;
  }

  return $nids;
}

/**
 * Helper that warns presenters who do NOT have a ticket for the day(s) on
 * which they're presenting.
 *
 * @param uid
 *   A user uid.
 */
function sessions_presenter_check($uid) {
  // Which days am I attending?
  $days = sessions_get_days($uid);

  // Which sessions am I presenting?
  $sessions = sessions_presenter($uid);

  if (!$sessions)
    return;

  // Which days are these sessions scheduled to be on?
  $query = "SELECT DISTINCT(cfdt.nid) AS nid FROM {content_field_day_timeslots} WHERE cfdt.field_day_timeslots_nid IN (%s)";
  $result = db_query($query, implode(', ', $days));

  while ($nid = db_result($result)) {
    if (!in_array($nid, $days)) {
      $nids[] = $nid;
    }
  }

  // I do not have a ticket for any days in $nids.
  foreach ($nids as $nid) {
    $day = node_load($nid);
    drupal_set_message(t('You are presenting a session on !title but have not yet bought a ticket', array('!day' => $day->title)), 'warning');
  }
}

/**
 * Helper that automagically assigns presenters to their own sessions and
 * keeps checking to make sure they ARE assigned to their own sessions.
 * It reports if it has detected and removed a clash.
 *
 * @param uid
 *   A user uid.
 */
function sessions_presenter_select($uid) {
  $sessions = sessions_presenter($uid);
  if (!$sessions)
    return;

  $selections = sessions_user_sessions($uid);

  foreach ($sessions as $session) {
    if (!in_array($session, $selections)) {
      // Need to add $session as a selection.
      $node = node_load($session);
      $timeslot = node_load($node->field_proposal_scheduled[0]['nid']);
      // Is there a conflict?
      $conflicts = sessions_conflicts($uid, $timeslot, $session);
      if ($conflicts) {
        // Display message
        $warning = t('This choice conflicts with a session you are presenting and it has been removed:<ul>');
        foreach ($conflicts as $conflict) {
          $warning .= t('<li>!title</li>', array('!title' => $conflict['title']));
        }
        $warning .= t('</ul>');
        drupal_Set_message($warning);

        $timeslots = sessions_overlapping_timeslots($timeslot->nid);
        foreach ($timeslots as $t) {
          db_query("DELETE FROM {ccc_session_selection} WHERE uid = %d AND timeslot = %d", $uid, $t);
        }
      }
      // Add the new selection to the database.
      //
      $query = "INSERT INTO {ccc_session_selection} (uid, nid, timeslot) VALUES (%d, %d, %d)";
      db_query($query, $uid, $session, $timeslot->nid);
      drupal_set_message(t('Added "!title", which you are presenting', array('!title' => $node->title)));
    } // end in_array
  } // end foreach
}

/**
 * Grab all timeslots that are associated with a particular day and order them by date.
 *
 * @param nid
 *   An day node id.
 */
function sessions_get_timeslots($nid) {
  $nids = array();
  $query = "SELECT ctt.nid FROM {content_field_day_timeslots} AS ctfd LEFT JOIN {content_type_timeslot} AS ctt ON (cfdt.field_day_timeslots_nid = ctt.nid) WHERE cfdt.nid = %d ORDER BY ctt.field_timeslot_date_value ASC, ctt.field_timeslot_date_value2 ASC";
  $result = db_query($query, $nid);
  while ($row = db_fetch_array($result)) {
    $nids[] = $row['nid'];
  }
  return $nids;
}

/**
 * Return the timeslots that start next (but are on the same day).
 *
 * This should include all concurrent sessions at this time.
 *
 * @param nid
 *   A timeslot or day node id.
 */
function sessions_next_timeslots($nid) {
  $nids = array();

  // Load the timeslot we want data for.
  $timeslot = node_load($nid);

  if ($timeslot->type == 'day') {
    // There is no previous timeslot, because we're the first session of the day.
    // First, grab the first timeslot nid and the lowest start time.
    $start = db_result(db_query("SELECT MIN(ctt.field_timeslot_date_value) FROM {content_field_day_timeslots} AS cfdt LEFT JOIN {content_type_timeslot} AS ctt ON (cfdt.field_day_timeslots_nid = ctt.nid) WHERE cfdt.nid = %d", $timeslot->nid));

    // Grab the timeslot nid that goes with this start time on this day.
    $nid = db_result(db_query("SELECT ctt.nid FROM {content_field_day_timeslots} AS cfdt LEFT JOIN {content_type_timeslot} AS ctt ON (cfdt.field_day_timeslots_nid = ctt.nid AND cfdt.nid = %d) WHERE ctt.field_timeslot_date_value = '%s'", $timeslot->nid, $start));
    $timeslot = node_load($nid);
  }
  else {
    // $timeslot contains the one we need to start *after*
    // First, grab the lowest start time *after* the $timeslot start time.
    // if ($match == 'start') {
    //   $start = db_result(db_query("SELECT MIN(ctt.field_timeslot_date_value) FROM {content_field_day_timeslots} AS cfdt LEFT JOIN {content_type_timeslot} AS ctt ON (cfdt.field_day_timeslots_nid = ctt.nid AND cfdt.nid = %d) WHERE field_timeslot_date_value > '%s'", $timeslot->day, $timeslot->field_timeslot_date[0]['value']));
    // }
    // else {
      $start = db_result(db_query("SELECT MIN(ctt.field_timeslot_date_value) FROM {content_field_day_timeslots} AS cfdt LEFT JOIN {content_type_timeslot} AS ctt ON (cfdt.field_day_timeslots_nid = ctt.nid AND cfdt.nid = %d) WHERE field_timeslot_date_value >= '%s'", $timeslot->day, $timeslot->field_timeslot_date[0]['value2']));
    // }
  }

//  global $run;
//  dpm(++$run . '  Find all timeslots that start after ' . $timeslot->field_timeslot_date[0]['value']);

  // If there is no such start time, just return.
  if (!$start)
    return $nids;

  // Then, grab the lowest "next" end time, counting from the lowest next start time.
  $finish = db_result(db_query("SELECT MIN(ctt.field_timeslot_date_value2) FROM {content_field_day_timeslots} AS cfdt LEFT JOIN {content_type_timeslot} AS ctt ON (cfdt.field_day_timeslots_nid = ctt.nid AND cfdt.nid = %d) WHERE field_timeslot_date_value >= '%s'", $timeslot->day, $start));

  // dpm('Going to return all timeslots that start at or after ' . $start . ' and end BEFORE ' . $finish);

  // Now grab all slots that start between these two values and are on the same day nid.
  $query = "SELECT ctt.nid, ctt.field_timeslot_date_value, ctt.field_timeslot_date_value2 FROM {content_field_day_timeslots} AS cfdt LEFT JOIN {content_type_timeslot} AS ctt ON (cfdt.field_day_timeslots_nid = ctt.nid AND cfdt.nid = %d) WHERE ctt.field_timeslot_date_value >= '%s' AND field_timeslot_date_value < '%s' ORDER BY field_timeslot_date_value ASC, field_timeslot_date_value2 ASC";
  $result = db_query($query, $timeslot->day, $start, $finish);

  while ($row = db_fetch_array($result)) {
    $nids[] = $row['nid'];
    $data[] = $row;
  }
//  dpm('Returning ' . count($nids) . ' timeslots');
//  dpm($data);

  return $nids;
}

/**
 * Helper to return a list if timeslot nodes that overlap with a given timeslot.
 * Overlap means timeslots that: simultaneous start time or start whilst the given slot is still going.
 *   - start at the same time as the given slot, or
 *   - start before the given slot finishes, but
 *   - do not start before the given slot, and
 *   - are on the same day.
 *
 * @param nid
 *   A timeslot node id.
 */
function sessions_overlapping_timeslots($nid) {
  $nids = array();

  $timeslot = node_load($nid);
  $query = "SELECT ctt.nid FROM {content_field_day_timeslots} AS cfdt LEFT JOIN {content_type_timeslot} AS ctt ON (cfdt.field_day_timeslots_nid = ctt.nid AND cfdt.nid = %d) WHERE (ctt.field_timeslot_date_value BETWEEN '%s' AND '%s')";
  $result = db_query($query, $timeslot->day,  $timeslot->field_timeslot_date[0]['value'], $timeslot->field_timeslot_date[0]['value2']);

  while ($row = db_fetch_array($result)) {
    $nids[] = $row['nid'];
  }
  return $nids;
}

/**
 * Grab a list of day nids that a user is attending. These in turn determine the timeslots the
 * user needs to choose sessions for. List the days by their date value.
 *
 * TODO: Return nids only if a ticket has been paid for.
 *
 * @integer uid
 *   The user's uid.
 */
function sessions_get_days($uid) {
  $nids = array();

  $query = "SELECT
     DISTINCT(cfrd.field_registration_day_nid) AS nid
   FROM
     {uc_order_products} AS uc_op
   LEFT JOIN
     {uc_orders} AS uc_o ON (uc_op.order_id = uc_o.order_id)
   LEFT JOIN
     {ccc_ticket_allocation} AS cccta ON (uc_op.order_product_id = cccta.order_product_id)
   LEFT JOIN
     {content_field_registration_day} AS cfrd ON (uc_op.nid = cfrd.nid)
   LEFT JOIN
     {content_type_day} AS ctd ON (cfrd.field_registration_day_nid = ctd.nid)
   WHERE
       cccta.uid = %d
     AND
       uc_o.order_status IN ('" . implode("','", variable_get('sessions_order_status', array('completed'))) ."')
   ORDER BY
     ctd.field_day_date_value ASC";
  $result = db_query($query, $uid);
  while ($row = db_fetch_array($result)) {
    $nids[] = $row['nid'];
  }

  return $nids;
}

/**
 * Retrieve a list of selected sessions for $user.
 *
 * @integer uid
 *   An integer referring to a user.
 */
function sessions_user_sessions($uid) {
  $selections = array();

  $query = "SELECT timeslot, nid FROM {ccc_session_selection} WHERE uid = %d";
  $result = db_query($query, $uid);
  while ($row = db_fetch_array($result)) {
    $selections[$row['timeslot']] = $row['nid'];
  }

  return $selections;
}

/**
 * Return a keyed array of session nid and titles for the selection form.
 *
 * @integer nid
 *   The nid for the timeslot we need a session list for.
 */
function sessions_timeslot_sessions($nid) {
  $options = array(0 => ' No session selected');
  $query = "SELECT n.nid, n.title
    FROM
      {node} AS n
    JOIN
      {content_type_proposal} AS ctp ON (n.nid = ctp.nid)
    WHERE
      ctp.field_proposal_scheduled_nid = %d";
  $result = db_query($query, $nid);
  while ($row = db_fetch_array($result)) {
    $options[$row['nid']] = $row['title'];
  }
  return $options;
}

/**
 * Helper that checks if a given user may choose a session for a given timeslot.
 *
 * @param user
 *   User uid.
 * @param nid
 *   Timeslot nid.
 */
function sessions_user_valid_timeslot($uid, $nid) {
  $query = "SELECT
     COUNT(ctt.nid)
   FROM
     {uc_order_products} AS uc_op
   JOIN
     {ccc_ticket_allocation} AS cccta ON (uc_op.order_product_id = cccta.order_product_id)
   JOIN
     {content_field_registration_day} AS cfrd ON (uc_op.nid = cfrd.nid)
   JOIN
     {content_field_day_timeslots} AS cfdt ON (cfdt.nid = cfrd.field_registration_day_nid)
   JOIN
     {content_type_timeslot} AS ctt ON (cfdt.field_day_timeslots_nid = ctt.nid)
   WHERE
     cccta.uid = %d AND ctt.nid=%d";
  return db_result(db_query($query, $uid, $nid));
}

/**
 * Display the session selection form
 *
 * @param user
 *   The user being viewed.
 * @param action
 *   A string indicating the action the user wants to take.
 * @param timeslot
 *   A timeslot node id.
 * @param session
 *   A session node id.
 */
function sessions_list($user, $action = NULL, $timeslot = NULL, $session = NULL) {
  drupal_set_title('Conference Session Selection');
  if ($action && $timeslot && $session) {
    return drupal_get_form('sessions_list_form', $user, $action, $timeslot, $session);
  }
  else {
    return sessions_list_table($user);
  }
}

function sessions_list_form($form_state, $user, $action, $timeslot, $session) {
  $form = array();
  $items = array();

  $timeslot = node_load($timeslot);
  $session = node_load($session);

  $form['#tree'] = TRUE;
  $form['#redirect'] = 'user/' . $user->uid . '/sessions';

  $form['uid'] = array(
    '#type' => 'hidden',
    '#value' => $user->uid,
  );
  $form['action'] = array(
    '#type' => 'hidden',
    '#value' => $action,
  );
  $form['timeslot'] = array(
    '#type' => 'hidden',
    '#value' => $timeslot->nid,
  );
  $form['session'] = array(
    '#type' => 'hidden',
    '#value' => $session->nid,
  );

  switch ($action) {
    case 'add':
      // Remove conflicting session selections.
      // ie: something in a timeslot that starts at or before this one and ends during or with this one.

      $conflicts = sessions_conflicts($user->uid, $timeslot, $session->nid);
      if ($conflicts) {
        $sessions  = theme('sessions_conflicts', $conflicts);
        $sessions .= '<p>' . t('If you click add, these earlier selections will be removed from your program.');
      }

      $title = t('Add session');
      $description = t('!conflicts Would you like to add "!title" to your program?', array('!conflicts' => $sessions, '!title' => $session->title));
      $submit = ($conflicts) ? t('Replace earlier selection') : t('Add to my program');
      $cancel = t('Back to list');
      break;

    case 'remove':
      $title = t('Remove session');
      $description = t('Really remove session "!title" from your program?', array('!title' => $session->title));
      $submit  = t('Remove');
      $cancel = t('Back to list');
      break;
  }

  if ($form) {
    // Set some default form values
    $form = confirm_form(
      $form,
      $title,
      $form_state['post']['listing'],
      $description,
      $submit,
      $cancel
    );
    return $form;
  }
}

function sessions_list_form_validate($form, &$form_state) {
  $user = user_load($form_state['values']['uid']);
  if (!$user->uid)
    form_set_error('uid', 'You need to be a user');

  $action = check_plain($form_state['values']['action']);

  $timeslot = node_load($form_state['values']['timeslot']);
  if (!$timeslot->nid || $timeslot->type != 'timeslot')
    form_set_error('timeslot', 'You need a valid timeslot');

  $session = node_load($form_state['values']['session']);
  if (!$session->nid || $session->type != 'proposal')
    form_set_error('session', 'You need a valid proposal');

  if ($session->field_proposal_scheduled[0]['nid'] != $timeslot->nid)
    form_set_error('session', 'The selected session is not in the selected timeslot');

  if ($action == 'add') {
    $room = node_load($session->field_proposal_room[0]['nid']);
    if ($room->field_room_capacity <= count($session->attendees))
      form_set_error('session', 'The selected session is full');
  }
}

function sessions_list_form_submit($form, &$form_state) {
  $uid = check_plain($form_state['values']['uid']);
  $action = check_plain($form_state['values']['action']);
  $timeslot = check_plain($form_state['values']['timeslot']);
  $session = check_plain($form_state['values']['session']);

  switch ($action) {
    case 'add':
      // Remove conflicting session selections.
      // ie: something in a timeslot that starts at or before this one and ends during or with this one.
      $timeslots = sessions_overlapping_timeslots($timeslot);
      foreach ($timeslots as $t) {
        db_query("DELETE FROM {ccc_session_selection} WHERE uid = %d AND timeslot = %d", $uid, $t);
      }

      // Add the new selection to the database.
      //
      $query = "INSERT INTO {ccc_session_selection} (uid, nid, timeslot) VALUES (%d, %d, %d)";
      db_query($query, $uid, $session, $timeslot);

      // Tell the user what we did.
      $session = node_load($session);
      drupal_set_message(t('Added session "!title"', array('!title' => $session->title)));
      break;

    case 'remove':
      $session = node_load($session);
      db_query("DELETE FROM {ccc_session_selection} WHERE uid = %d AND nid = %d", $uid, $session->nid);
      drupal_set_message(t('Removed session "!title"', array('!title' => $session->title)));
      break;
  }
}

/**
 * Show the user which sessions they've selected sofar.
 *
 * @array form_state
 *   The current state of the form.
 * @object user
 *   The user being viewed.
 */
function sessions_list_table($user) {

  // Do some sanity checking.
  sessions_presenter_check($user->uid);
  sessions_presenter_select($user->uid);

  $output = '';
  $days = sessions_get_days($user->uid);
  $selections = sessions_user_sessions($user->uid);

  // Need the timezone offset. Ugh. Used *ONLY* for display purposes, not in the utility functions that fetch data.
  $offset = variable_get('date_default_timezone', 0);
  $offset -= 3600;

  if (!$days) {
    return t('There are no sessions to be selected. Please check that your order payment status is <en>completed</em> and that a ticket has been assigned to you.');
  }

  // Now, loop through the list of day nids.
  foreach ($days as $day_nid) {
    // Load a day nid.
    $day = node_load($day_nid);

    // Set the first timeslot to the day.
    $timeslot = $day;

    $data = array();
    $headers = array('Time', 'Selected Session', 'Change', 'Remove');

    $output .= '<h3>' . $day->title . '</h3>';
    $output .= '<p>' .  t('These are your session selections for !day.', array('!day' => $day->title));

    // Get the timeslots that are "up next". On the first run this function accepts a day node.
    //
    while ($nids = sessions_next_timeslots($timeslot->nid)) {

      // Check if the user has made a selection for one of these timeslots.
      // Check if any of the values of $nids matches any of the keys of $selected.
      if (($selected = sessions_check_selected($nids, $selections)) !== FALSE) {

        // dpm('Found selection ' . $selections[$selected] . ' for timeslot ' . $selected);

        $timeslot = node_load($selected);
        $session = node_load($selections[$selected]);

        $tuple = array(
          'timeslot' => $timeslot->between,
          'session' => l($session->title, 'node/' . $session->nid),
          // 'action' => t('!link', array('!link' => l('Also on...', 'program/schedule/timeslot/' . implode('+', $nids))))
          // 'action' => theme('sessions_form', 'Change...', url('program/schedule/timeslot/' . implode('+', $nids))),
          'action' => theme('sessions_form', 'Change...', url('program/schedule/timeslot/' . implode('+', $nids))),
          'remove' => theme('sessions_form', 'Remove', url('user/' . $user->uid . '/sessions/remove/' . $timeslot->nid . '/' . $session->nid), NULL, 'form-submit-red'),
        );
        $data[] = $tuple;
      }
      else {
        // No selection, display a list of timeslots and jump to the associated sessions.
        // dpm('No selections found, load up timeslot ' . $nids[0]);

        $timeslot = node_load($nids[count($nids)-1]);
        $times = sessions_min_max_times($nids);
        $endtimes = sessions_min_max_end_times($nids);

        $tuple = array(
          'timeslot' => t('!start - !endmin!endmax',
             array('!start' => date('H:i', strtotime($times['start'])+$offset),
                   '!endmin' => date('H:i', strtotime($endtimes['minimum'])+$offset),
                   '!endmax' => ($endtimes['minimum']!=$endtimes['maximum']) ? '/' . date('H:i', strtotime($endtimes['maximum'])+$offset) : ''
             )),
          'session' => null,
          // 'change' => t('!link', array('!link' => l('Choose...', 'program/schedule/timeslot/' . implode('+', $nids)))),
          'action' => theme('sessions_form', 'Sessions...', url('program/schedule/timeslot/' . implode('+', $nids))),
        );
        $data[] = $tuple;
      } // endif
    } // end while nids

    // Add a table with timeslots and selections for today.
    //
    $output .= theme('table', $headers, $data);

  } // end foreach days

  return $output;
}

/**
 * Helper to check if the value of array1 is a key in array2.
 */
function sessions_check_selected($timeslots, $selections) {
  foreach ($selections as $timeslot => $session) {
    if (in_array($timeslot, $timeslots)) {
      return $timeslot;
    }
  }
  return FALSE;
}

/**
 * Return a list of already selected sessions that conflict with the given one.
 *
 * @param uid
 *   A valid user id.
 * @param timeslot.
 *   A timeslot node.
 *
 * @return
 *   An array of conflicting session titles.
 */
function sessions_conflicts($uid, $timeslot, $session = 0) {
  $conflicts = array();
  $selections = sessions_user_sessions($uid);
  $timeslots = sessions_overlapping_timeslots($timeslot->nid);

  foreach ($selections as $slot => $selection) {
    // A current selection should not clash with itself :-)
    if ($selection == $session)
      continue;

    if (in_array($slot, $timeslots)) {
      $proposal = node_load($selection);
      $conflicts[$slot] = array('nid' => $proposal->nid, 'title' => $proposal->title);
    }
  }
  return $conflicts;
}

/**
 * Helper to retrieve the earliest and latest times from a set of given timeslots.
 */
function sessions_min_max_times($nids) {
  $result = db_query("SELECT MIN(field_timeslot_date_value) AS start, MAX(field_timeslot_date_value2) AS end FROM {content_type_timeslot} WHERE nid IN (" . implode(',', $nids) . ")");
  return db_fetch_array($result);
}

/**
 * Helper to retrieve the earliest and latest *end* times from a set of given timeslots.
 */
function sessions_min_max_end_times($nids) {
  $result = db_query("SELECT MIN(field_timeslot_date_value2) AS minimum, MAX(field_timeslot_date_value2) AS maximum FROM {content_type_timeslot} WHERE nid IN (" . implode(',', $nids) . ")");
  return db_fetch_array($result);
}

/**
 * Helper to retrieve the raw start and end times from a given timeslot.
 */
function sessions_raw_end_time($nid) {
  $result = db_query("SELECT field_timeslot_date_value AS start, field_timeslot_date_value2 AS end FROM {content_type_timeslot} WHERE nid = %d", $nid);
  return db_fetch_array($result);
}

/**
 * Return the number of places available for a session.
 */
function sessions_places($nid) {
  $session = node_load($nid);
  $room = node_load($session->field_proposal_room[0]['nid']);
  return $room->field_room_capacity[0]['value'];
}

/**
 * Return a list of attendees for a session.
 */
function sessions_attendees($nid) {
  $users = array();
  $result = db_query("SELECT uid FROM {ccc_session_selection} WHERE nid = %d", $nid);
  while ($row = db_fetch_array($result)) {
    $users[] = $row['uid'];
  }
  return $users;
}

/**
 * Implementation of hook_theme()
 */
function sessions_theme() {
  $path = drupal_get_path('module', 'sessions');
  return array(
    'sessions_form' => array(
      'arguments' => array('submit' => $submit, 'action' => $action, 'hidden' => array(), 'colour' => $colour),
      'template' => 'sessions-form',
      'path' => "$path/theme",
    ),
    'sessions_conflicts' => array(
      'arguments' => array('conflicts' => $conflicts),
      'template' => 'sessions-conflict',
      'path' => "$path/theme",
    ),
    'sessions_timeslot' => array(
      'arguments' => array('timeslot' => $timeslot, 'fields' => array('value' => 'H:i')),
    ),
  );
}

/**
 * Theme functions.
 */
function theme_sessions_timeslot($timeslot, $fields) {
  // Need the timezone offset. Ugh. Used *ONLY* for display purposes, not in the utility functions that fetch data.
  $offset = variable_get('date_default_timezone', 0);
  $offset -= 3600;

  $output = '';

  foreach ($fields as $field => $format) {
    $datetime = strtotime($timeslot->field_timeslot_date[0][$field]);
    $datetime += $offset;

    $output .= '<span style="date date-' . $field. '">';
    $output .= date($format, $datetime);
    $output .= '</span>';
  }
  return $output;
}
