<?php

/**
 *
 * Handle session selection info
 *
 * We are coupling a bit with registration. AFter all, we need to know which ticket
 * a user has purchased, so we can allow them to pick appropriate sessions.
 */

/**
 * Implementation of hook_perm().
 *
 */
function sessions_perm() {
  return array('select conference sessions');
}


/**
 * Implementation of hook_nodeapi()
 */
function sessions_nodeapi(&$node, $op) {
  if($node->type == 'timeslot' && $op == 'load') {
    $dateparts = split(' ', $node->title);
    $node->between = t('!start - !end', array('!start' => $dateparts[4], '!end' => $dateparts[6]));
  }
}

/**
 * Implementation of hook_menu().
 */
function sessions_menu() {
  $items = array();

  $items['user/%user/sessions'] = array(
    'title' => 'Session Selections',
    'description' => 'Conference session selection',
    'page callback' => 'sessions_list',
    'page arguments' => array(1, 3, 4),
    'access callback' => 'user_access',
    'access arguments' => array('select conference sessions'),
    'type' => MENU_LOCAL_TASK,
  );

  return $items;
}

/**
 * Implementation of hook_user().
 */
function sessions_user($op, &$edit, &$account, $category = NULL) {
  global $user;
  switch ($op) {
    case 'view':
      if ($user->uid && (($user->uid == $account->uid && user_access('select conference sessions')))) {

        // Get a big list of selected sessions.
        $sessions = sessions_user_sessions($account->uid);

        // Show selected sessions.
        $account->content['selections'] = array(
          '#type' => 'user_profile_category',
          '#weight' => 0,
          '#title' => t('Session Selections'),
          'link' => array(
            '#type' => 'user_profile_item',
            '#value' => theme('user_overview_registrations', $account, $sessions),
          ),
        );
      }
      break;

    case 'load':
      $user->selections = sessions_user_sessions($account->uid);
      break;
  }
}

/**
 * Grab all timeslots that happen to be on a particular day.
 *
 * @string date
 *   An YYYY-MM-DD formatted date.
 */
function sessions_get_timeslots($date) {
  $nids = array();
  $query = "SELECT ctt.nid FROM {content_type_timeslot} AS ctt WHERE field_timeslot_date_value LIKE '%s% %%' ORDER BY field_timeslot_date_value ASC, field_timeslot_date_value2 ASC";
  $result = db_query($query, $date);
  while ($row = db_fetch_array($result)) {
    $nids[] = $row['nid'];
  }
  return $nids;
}

/**
 * Return the timeslots that start next (but are on the same day).
 *
 * This should include all concurrent sessions at this time.
 *
 * @string date
 *   An YYYY-MM-DD formatted date.
 * @string time
 *   An HH:MM:SS formatted time.
 */
function sessions_next_timeslots($date, $time = '00:00:00') {
  $nids = array();

  // dpm('Find timeslots that start at or after ' . $date . ' ' . $time);

  // First, grab the lowest "next" start time.
  $start = db_result(db_query("SELECT MIN(ctt.field_timeslot_date_value) FROM {content_type_timeslot} AS ctt WHERE field_timeslot_date_value >= '%s %s' AND field_timeslot_date_value LIKE '%s%%'", $date, $time, $date));

  // If there is no such start time, just return.
  if (!$start)
    return $nids;

  // Then, grab the lowest "next" end time, counting from the lowest next start time.
  $finish = db_result(db_query("SELECT MIN(ctt.field_timeslot_date_value2) FROM {content_type_timeslot} AS ctt WHERE field_timeslot_date_value >= '%s' AND field_timeslot_date_value LIKE '%s%%'", $start, $date));

  // dpm('Going to return all timeslots that start at or after ' . $start . ' and end BEFORE ' . $finish);

  // Now grab all slots that start between these two values.
  $query = "SELECT ctt.nid, field_timeslot_date_value, field_timeslot_date_value2 FROM {content_type_timeslot} AS ctt WHERE field_timeslot_date_value >= '%s' AND field_timeslot_date_value < '%s' ORDER BY field_timeslot_date_value ASC, field_timeslot_date_value2 ASC";
  $result = db_query($query, $start, $finish);

  while ($row = db_fetch_array($result)) {
    $nids[] = $row['nid'];
    $data[] = $row;
  }
  // dpm('Returning ' . count($nids) . ' timeslots');
  // dpm($data);
  return $nids;
}

/**
 * Helper to return a list if timeslot nodes that overlap with a given timeslot.
 * Overlap means timeslots that: simultaneous start time or start whilst the given slot is still going.
 *   - start at the same time as the given slot, or
 *   - start before the given slot finishes, but
 *   - do not start before the given slot.
 *
 * @object timeslot
 *   A timeslot node.
 */
function sessions_overlapping_timeslots($timeslot) {
  $nids = array();

  $timeslot = node_load($timeslot);
  $query = "SELECT ctt.nid FROM {content_type_timeslot} AS ctt WHERE (ctt.field_timeslot_date_value BETWEEN '%s' AND '%s')";
  $result = db_query($query, $timeslot->field_timeslot_date[0]['value'], $timeslot->field_timeslot_date[0]['value2']);

  while ($row = db_fetch_array($result)) {
    $nids[] = $row['nid'];
  }
  return $nids;
}

/**
 * Grab a list of days that a user is attending.
 *
 * @integer uid
 *   The user's uid.
 */
function sessions_get_days($uid) {

  $query = "SELECT
     DISTINCT(DATE_FORMAT(ctt.field_timeslot_date_value, '%%Y-%%m-%%d'))
   FROM
     {uc_order_products} AS uc_op
   JOIN
     {ccc_ticket_allocation} AS cccta ON (uc_op.order_product_id = cccta.order_product_id)
   JOIN
     {content_field_registration_timeslot} AS cfrt ON (uc_op.nid = cfrt.nid)
   JOIN
     {content_type_timeslot} AS ctt ON (cfrt.field_registration_timeslot_nid = ctt.nid)
   WHERE
     cccta.uid = %d";
  $result = db_query($query, $uid);
  while ($day = db_result($result)) {
    $data[] = $day;
  }
  return $data;

}

/**
 * Grab a set of days based on timeslots.
 *
 * @array timeslots
 *   An array of timeslot info.
 */
function sessions_timeslots_to_days($timeslots) {
  $days = array();
  foreach($timeslots as $timeslot) {
    $date = split(' ', $timeslot->field_timeslot_date_value);
    $days[$date[0]] = $date[0];
  }
  return $days;
}

/**
 * Retrieve a list of selected sessions for $user.
 *
 * @integer uid
 *   An integer referring to a user.
 */
function sessions_user_sessions($uid) {
  $data = array();
  $query = "SELECT timeslot, nid FROM {ccc_session_selection} WHERE uid = %d";
  $result = db_query($query, $uid);
  while ($row = db_fetch_array($result)) {
    $data[$row['timeslot']] = $row['nid'];
  }
  return $data;
}

/**
 * Return a keyed array of session nid and titles for the selection form.
 *
 * @integer nid
 *   The nid for the timeslot we need a session list for.
 */
function sessions_timeslot_sessions($nid) {
  $options = array(0 => ' No session selected');
  $query = "SELECT n.nid, n.title
    FROM
      {node} AS n
    JOIN
      {content_type_proposal} AS ctp ON (n.nid = ctp.nid)
    WHERE
      ctp.field_proposal_scheduled_nid = %d";
  $result = db_query($query, $nid);
  while ($row = db_fetch_array($result)) {
    $options[$row['nid']] = $row['title'];
  }
  return $options;
}

/**
 * Display the session selection form
 *
 * @object user
 *   The user being viewed.
 */
function sessions_list($user, $timeslot = NULL, $session = NULL) {
  drupal_set_title('Conference session selection');
  if ($timeslot && $session) {
    return drupal_get_form('sessions_form_confirm', $user, $timeslot, $session);
  }
  else {
    return drupal_get_form('sessions_form', $user);
  }
}

function sessions_form_confirm($form_state, $user, $timeslot, $session) {
  $form = array();
  $items = array();

  $timeslot = node_load($timeslot);
  $session = node_load($session);

  $form['#tree'] = TRUE;

  $form['uid'] = array(
    '#type' => 'hidden',
    '#value' => $user->uid,
  );
  $form['timeslot'] = array(
    '#type' => 'hidden',
    '#value' => $timeslot->nid,
  );
  $form['session'] = array(
    '#type' => 'hidden',
    '#value' => $session->nid,
  );

  // Remove conflicting session selections.
  // ie: something in a timeslot that starts at or before this one and ends during or with this one.

  $conflicts = sessions_conflicts($user, $timeslot);
  if ($conflicts) {
    $sessions  = '<p>' . t('Your choice conflicts with some of the selections you made earlier:');
    $sessions .= '<ul><li>';
    $sessions .= implode('<li>', $conflicts);
    $sessions .= '</ul>';
    $sessions .= '<p>' . t('If you click add, these earlier selections will be removed from your program.');
  }

  if ($form) {
    // Set some default form values
    $form = confirm_form(
      $form,
      t('!title', array('!title' => $session->title)),
      'user/' . $user->uid . '/sessions',
      t('!conflicts Would you like to add this session to your program?', array('!conflicts' => $sessions)),
      t('Add to my program'),
      t('Cancel'));
    return $form;
  }
}

function sessions_form_confirm_validate($form, &$form_state) {
  $user = user_load($form_state['values']['uid']);
  if (!$user->uid)
    form_set_error('uid', 'You need to be a user');

  $timeslot = node_load($form_state['values']['timeslot']);
  if (!$timeslot->nid || $timeslot->type != 'timeslot')
    form_set_error('timeslot', 'You need a valid timeslot');

  $session = node_load($form_state['values']['session']);
  if (!$session->nid || $session->type != 'proposal')
    form_set_error('session', 'You need a valid proposal');

  if ($session->field_proposal_scheduled[0]['nid'] != $timeslot->nid)
    form_set_error('session', 'The selected session is not in the selected timeslot');
}

function sessions_form_confirm_submit($form, &$form_state) {
  $uid = $form_state['values']['uid'];
  $timeslot = $form_state['values']['timeslot'];
  $session = $form_state['values']['session'];

  // Remove conflicting session selections.
  // ie: something in a timeslot that starts at or before this one and ends during or with this one.
  $timeslots = sessions_overlapping_timeslots($timeslot);
  foreach ($timeslots as $t) {
    db_query("DELETE FROM {ccc_session_selection} WHERE uid = %d AND timeslot = %d", $uid, $t);
  }

  // Add the new selection to the database.
  //
  $query = "INSERT INTO {ccc_session_selection} (uid, nid, timeslot) VALUES (%d, %d, %d)";
  db_query($query, $uid, $session, $timeslot);

  // Tell the user what we did.
  $session = node_load($session);
  drupal_set_message(t('!title was added to your personalised program', array('!title' => $session->title)));
}

/**
 * Show the user which sessions they've selected sofar.
 *
 * @array form_state
 *   The current state of the form.
 * @object user
 *   The user being viewed.
 */
function sessions_form($form_state, $user) {

  $days = sessions_get_days($user->uid);
  $selections = sessions_user_sessions($user->uid);

  // Need the timezone offset. Ugh. Used *ONLY* for display purposes, not in the utility functions that fetch data.
  $offset = variable_get('date_default_timezone', 0);
  $offset -= 3600;

  foreach ($days as $day) {
    $data = array();
    $headers = array('Time', 'Selected Session', 'Change');

    $datetime = strtotime($day);

    $form['sessions']['days'][$day] = array(
      '#type' => 'fieldset',
      '#title' => strftime('%b %e %b', $datetime),
      '#description' => t('These are your session selections for !date.', array('!date' => strftime('%B %e %B %Y', $datetime))),
      '#collapsible' => TRUE,
    );

    // Format the date and time so the timeslot fetching function can cope.
    $date = date('Y-m-d', $datetime);
    $time = date('H:i:s', $datetime);

    // Get the timeslots that are "up next".
    while ($nids = sessions_next_timeslots($date, $time)) {

      // Check if the user has made a selection for one of these timeslots.
      // Check if any of the values of $nids matches any of the keys of $selected.
      if (($selected = sessions_check_selected($nids, $selections)) !== FALSE) {

        // dpm('Found selection ' . $selections[$selected] . ' for timeslot ' . $selected);

        $timeslot = node_load($selected);
        $session = node_load($selections[$selected]);

        $tuple = array(
          'timeslot' => $timeslot->between,
          'session' => $session->title,
          'change' => t('!link', array('!link' => l('Also on...', 'program/schedule/timeslot/' . implode('+', $nids))))
        );
        $data[] = $tuple;

        // Grab the raw end time for this timeslot.
        $times = sessions_raw_end_time($timeslot->nid);
      }
      else {
        // No selection, display a list of timeslots and jump to the associated sessions.
        // dpm('No selections found, load up timeslot ' . $nids[0]);

        $timeslot = node_load($nids[0]);
        $times = sessions_min_max_times($nids);
        $endtimes = sessions_min_max_end_times($nids);

        $tuple = array(
          'timeslot' => t('!start - !endmin!endmax',
             array('!start' => date('H:i', strtotime($times['start'])+$offset),
                   '!endmin' => date('H:i', strtotime($endtimes['minimum'])+$offset),
                   '!endmax' => ($endtimes['minimum']!=$endtimes['maximum']) ? '/' . date('H:i', strtotime($endtimes['maximum'])+$offset) : ''
             )),
          'session' => null,
          'change' => t('!link', array('!link' => l('Choose...', 'program/schedule/timeslot/' . implode('+', $nids)))),
        );
        $data[] = $tuple;
      } // endif

      list($date, $time) = split(' ', $times['end']);
    } // end while nids

    // Add a table with timeslots and selections for today.
    //
    $form['sessions']['days'][$day]['selections'] = array(
      '#type' => 'markup',
      '#value' => theme('table', $headers, $data),
    );

  } // end foreach days

  return $form;
}

/**
 * Helper to check if the value of array1 is a key in array2.
 */
function sessions_check_selected($timeslots, $selections) {
  foreach ($selections as $timeslot => $session) {
    if (in_array($timeslot, $timeslots)) {
      return $timeslot;
    }
  }
  return FALSE;
}

/**
 * Return a list of already selected sessions that conflict with the given one.
 *
 * @param user
 *   A valid user object.
 * @param timeslot.
 *   A timeslot node.
 *
 * @return
 *   An array of conflicting session titles.
 */
function sessions_conflicts($user, $timeslot) {
  $conflicts = array();
  $selections = sessions_user_sessions($user->uid);
  $timeslots = sessions_overlapping_timeslots($timeslot->nid);

  foreach ($selections as $slot => $selection) {
    if (in_array($slot, $timeslots)) {
      $proposal = node_load($selection);
      $conflicts[$slot] = $proposal->title;
    }
  }
  return $conflicts;
}

/**
 * Helper to retrieve the earliest and latest times from a set of given timeslots.
 */
function sessions_min_max_times($nids) {
  $result = db_query("SELECT MIN(field_timeslot_date_value) AS start, MAX(field_timeslot_date_value2) AS end FROM {content_type_timeslot} WHERE nid IN (" . implode(',', $nids) . ")");
  return db_fetch_array($result);
}

/**
 * Helper to retrieve the earliest and latest *end* times from a set of given timeslots.
 */
function sessions_min_max_end_times($nids) {
  $result = db_query("SELECT MIN(field_timeslot_date_value2) AS minimum, MAX(field_timeslot_date_value2) AS maximum FROM {content_type_timeslot} WHERE nid IN (" . implode(',', $nids) . ")");
  return db_fetch_array($result);
}

/**
 * Helper to retrieve the raw start and end times from a given timeslot.
 */
function sessions_raw_end_time($nid) {
  $result = db_query("SELECT field_timeslot_date_value AS start, field_timeslot_date_value2 AS end FROM {content_type_timeslot} WHERE nid = %d", $nid);
  return db_fetch_array($result);
}
